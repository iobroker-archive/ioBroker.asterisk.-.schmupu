{
  "version": 3,
  "sources": ["../../src/lib/transcode.ts"],
  "sourcesContent": ["import childProcess from 'child_process';\nimport fs from 'fs';\nimport * as googleTTS from 'google-tts-api';\nimport path from 'path';\nimport * as tools from './tools';\n\n/**\n * Test function, text to speech gsm\n *\n * @param text text which will be converted\n * @param filename filenmae of gsm file\n * @returns base64 string of gsm file\n */\nexport async function test(text: string, filename: string): Promise<string> {\n    try {\n        const converter = new TextToGSMConverter({ transcoder: 'ffmpeg', language: 'de' });\n        const base64 = converter.textToGsm(text, `${filename}.gsm`, 100);\n        return base64;\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (err) {\n        // error\n    }\n    return '';\n}\n\n/**\n * Text to MP3 converter. A lot of the logik is from the ioBroker.sayit adapter.\n * MP3 to GSM transcoder. The shell program ffmpeg is needed\n *\n */\nexport class TextToGSMConverter {\n    private options: { transcoder: string; language: string };\n\n    /**\n     * Constructor\n     *\n     * @param options options\n     * @param options.transcoder ffmpeg or sox\n     * @param options.language language like de or en\n     */\n    constructor(options: { transcoder: string; language: string }) {\n        this.options = options;\n    }\n\n    /**\n     * Get Transcoder\n     *\n     * @returns transcoder like sox or ffmpeg\n     */\n    private getTranscoder(): string {\n        return this.options.transcoder;\n    }\n\n    /**\n     * Get Language\n     *\n     * @returns language like en or de\n     */\n    private getLanguage(): string {\n        return this.options.language;\n    }\n\n    /**\n     * Convert filename with ending gsm to endning mp3\n     *\n     * @param fileNameGSM filename with gsm ending\n     * @returns filenameMP3\n     */\n    public getMp3FromGSMfilename(fileNameGSM: string): string {\n        return fileNameGSM.replace(/.gsm$/i, '.mp3');\n    }\n\n    /**\n     * Convert filename with ending mp3 to endning gsm\n     *\n     * @param fileNameMP3 filename with gsm ending\n     * @returns filenameGSM\n     */\n    public getGSMFromMp3filename(fileNameMP3: string): string {\n        return fileNameMP3.replace(/.mp3$/i, '.gsm');\n    }\n\n    /**\n     * delete file from drive\n     *\n     * @param filename filename\n     * @returns true if deleted\n     */\n    public rmfile(filename: string): boolean {\n        if (fs.existsSync(filename)) {\n            fs.unlinkSync(filename);\n        }\n        if (fs.existsSync(filename)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * converts text to mp3 (speech) and saves it to a file\n     *\n     * @param text text which will be converted to speech\n     * @param fileNameMP3 mp3 filenme inkl. path\n     * @param volume not used\n     * @returns speech as base64 string\n     */\n    public async textToMp3(text: string, fileNameMP3: string, volume?: number): Promise<string> {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const vol = volume;\n        const rets = await googleTTS.getAllAudioBase64(text, {\n            lang: this.options.language.toLowerCase(),\n            slow: false,\n        });\n        let base64 = '';\n        for (const ret of rets) {\n            base64 += ret.base64;\n        }\n        const buffer = Buffer.from(base64, 'base64');\n        this.rmfile(fileNameMP3);\n        fs.writeFileSync(fileNameMP3, buffer, { encoding: 'base64' });\n        return base64;\n    }\n\n    /**\n     * converts text to gsm (speech) and saves it to a file\n     *\n     * @param text text which will be converted to speech\n     * @param fileNameGSM gsm filenme inkl. path\n     * @param volume not used\n     * @returns speech as base64 string\n     */\n    public async textToGsm(text: string, fileNameGSM: string, volume?: number): Promise<string> {\n        const fileNameMP3 = `${path.dirname(fileNameGSM)}/${tools.getGuid()}.mp3`;\n        switch (this.options.transcoder) {\n            case 'ffmpeg': {\n                await this.textToMp3(text, fileNameMP3, volume);\n                const base64 = await this.mp3ToGsmFfmpeg(fileNameMP3, fileNameGSM);\n                fs.unlinkSync(fileNameMP3);\n                return base64;\n            }\n            case 'sox': {\n                await this.textToMp3(text, fileNameMP3, volume);\n                const base64 = await this.mp3ToGsmSox(fileNameMP3, fileNameGSM);\n                fs.unlinkSync(fileNameMP3);\n                return base64;\n            }\n            default:\n                throw new Error(`Transcoder has to be sox or ffmpeg and not ${this.options.transcoder}`);\n        }\n    }\n\n    /**\n     * converts mp3 to gsm (speech) and saves it to a file\n     *\n     * @param fileNameMP3 mp3 filenme inkl. path\n     * @param fileNameGSM gsm filenme inkl. path\n     * @param volume not used\n     * @returns speech as base64 string\n     */\n    public async mp3ToGsm(fileNameMP3: string, fileNameGSM: string, volume?: number): Promise<string> {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const vol = volume;\n        switch (this.options.transcoder) {\n            case 'ffmpeg':\n                return await this.mp3ToGsmFfmpeg(fileNameMP3, fileNameGSM);\n            case 'sox':\n                return await this.mp3ToGsmSox(fileNameMP3, fileNameGSM);\n            default:\n                throw new Error(`Transcoder has to be sox or ffmpeg and not ${this.options.transcoder}`);\n        }\n    }\n\n    private async mp3ToGsmFfmpeg(fileNameMP3: string, fileNameGSM: string): Promise<string> {\n        return new Promise((resolve, reject) => {\n            if (!fs.existsSync(fileNameMP3)) {\n                reject(new Error(`File ${fileNameMP3} does not exists!`));\n            }\n            this.rmfile(fileNameGSM);\n            const ffmpeg = childProcess.spawn('ffmpeg', [\n                '-i',\n                fileNameMP3,\n                '-loglevel',\n                'error',\n                '-c:a',\n                'libgsm',\n                '-ar',\n                '8000',\n                '-ab',\n                '13000',\n                '-ac',\n                '1',\n                '-f',\n                'gsm',\n                '-y',\n                fileNameGSM,\n            ]);\n            ffmpeg.on('exit', (code: number) => {\n                if (code === 0) {\n                    const base64 = fs.readFileSync(fileNameGSM, { encoding: 'base64' });\n                    if (fs.existsSync(fileNameGSM)) {\n                        resolve(base64);\n                    } else {\n                        reject(new Error(`Error, file ${fileNameGSM} does not exists!`));\n                    }\n                } else {\n                    reject(new Error(`Error transcoding file from MP3 to GSM`));\n                }\n            });\n            ffmpeg.on('error', (err: { message: any }) =>\n                reject(new Error(`Error transcoding file from MP3 to GSM, ${err.message}`)),\n            );\n        });\n    }\n\n    private async mp3ToGsmSox(fileNameMP3: string, fileNameGSM: string): Promise<string> {\n        return new Promise((resolve, reject) => {\n            if (!fs.existsSync(fileNameMP3)) {\n                reject(new Error(`File ${fileNameMP3} does not exists!`));\n            }\n            this.rmfile(fileNameGSM);\n            const sox = childProcess.spawn('sox', [fileNameMP3, '-r', '8000', '-c', '1', fileNameGSM]);\n            sox.on('exit', code => {\n                if (code === 0) {\n                    const base64 = fs.readFileSync(fileNameGSM, { encoding: 'base64' });\n                    if (fs.existsSync(fileNameGSM)) {\n                        resolve(base64);\n                    } else {\n                        reject(Error(`Error, file ${fileNameGSM} does not exists!`));\n                    }\n                } else {\n                    reject(Error(`Error transcoding file from MP3 to GSM`));\n                }\n            });\n            sox.on('error', err => reject(new Error(`Error transcoding file from MP3 to GSM, ${err.message}`)));\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": ["fs", "path", "childProcess"]
}
